(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('babel-runtime/core-js/json/stringify')) :
  typeof define === 'function' && define.amd ? define(['exports', 'babel-runtime/core-js/json/stringify'], factory) :
  (factory((global.slim-redux = global.slim-redux || {}),global._JSON$stringify));
}(this, (function (exports,_JSON$stringify) { 'use strict';

_JSON$stringify = 'default' in _JSON$stringify ? _JSON$stringify['default'] : _JSON$stringify;

var performPayloadValidation = function performPayloadValidation(actionType, payload, payloadValidation) {
  var accept = function accept() {
    return { type: 'accept' };
  };
  var reject = function reject() {
    var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return { type: 'reject', payload: msg };
  };

  var validation = payloadValidation(payload, accept, reject);

  if (validation.type === 'reject') dispatchErrorAction(actionType, validation.payload);

  return validation.type;
};

function change(parameters) {
  var actionType = parameters.actionType || null,
      reducer = parameters.reducer,
      payloadValidation = parameters.payloadValidation || null;

  if (actionType) {
    // This change has an ACTION_TYPE, which means we can register it in the reducer
    registerReducer(actionType, reducer, payloadValidation);

    // Create and return change trigger function (has payload as the only parameter, will trigger validation)
    return function (actionPayload) {
      var validation = 'accept';

      if (payloadValidation) validation = performPayloadValidation(actionType, actionPayload, payloadValidation);

      if (validation === 'accept') {
        dispatchStoreAction({
          type: actionType,
          payload: actionPayload
        });
      }
    };
  } else {
    // Anonymous change (no ACTION_TYPE) - don't register, just dispatch the appropriate action!
    return function (actionPayload) {
      var validation = 'accept';

      if (payloadValidation) validation = performPayloadValidation(actionType, actionPayload, payloadValidation);

      if (validation === 'accept') {
        dispatchStoreAction({
          type: '__ANONYMOUS_CHANGE__',
          payload: {
            reducer: reducer,
            payload: actionPayload
          }
        });
      }
    };
  }
}

var storeDispatch = null;
var reducers = {};

function registerStoreDispatch(dispatch) {
  storeDispatch = dispatch;
}

function initSlimRedux(store) {
  store['change'] = change;
  registerStoreDispatch(store.dispatch);
}

function dispatchStoreAction(action) {
  storeDispatch(action);
}

function dispatchErrorAction(actionType, payload) {
  storeDispatch({
    type: actionType,
    error: true,
    payload: payload
  });

  console.error('***Error action triggered: \n ' + _JSON$stringify({
    type: actionType,
    error: true,
    payload: payload
  }, null, 2));
}

function getReducer(actionType) {
  if (actionType in reducers) return reducers[actionType].reducer;else return null;
}

function registerReducer(actionType, reducer, inputValidation) {
  var newReducer = {
    reducer: reducer,
    inputValidation: inputValidation
  };

  reducers[actionType] = newReducer;
}

function createSlimReduxReducer(initialState) {
  return function slimReduxReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments[1];

    if (action.type === '__ANONYMOUS_CHANGE__') {
      // Action was created by slim-redux and is an "anonymous" change - a change to the store without a named action
      // Action contains everything that the reducer needs to make the changes to the store
      var payload = action.payload.payload,
          reducer = action.payload.reducer;

      return reducer(state, payload, '__ANONYMOUS_CHANGE__');
    } else {
      // Action was triggered by a named change or dispatched by regular redux code
      var _reducer = getReducer(action.type);

      if (_reducer) {
        return _reducer(state, action.payload, action);
      } else {
        return state;
      }
    }
  };
}

exports.createSlimReduxReducer = createSlimReduxReducer;
exports.initSlimRedux = initSlimRedux;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
